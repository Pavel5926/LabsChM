\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage[pdftex]{graphicx}
\usepackage{amsmath}
\usepackage{geometry} % Меняем поля страницы
\geometry{left=1.5cm}% левое поле
\geometry{right=2cm}% правое поле
\geometry{top=1cm}% верхнее поле
\geometry{bottom=2cm}% нижнее поле
\graphicspath{{.}}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}

\begin{document}

\begin{titlepage}
\Large

\begin{center}
Санкт-Петербургский \\ Политехнический университет Петра Великого

\vspace{10em}

Отчет по лабораторной работе №2\\

\vspace{2em}

\textbf{Решение СЛАУ итерационными методами}
\end{center}

\vspace{6em}

\newbox{\lbox}
\savebox{\lbox}{\hbox{Попов Павел Сергеевич}}
\newlength{\maxl}
\setlength{\maxl}{\wd\lbox}
\hfill\parbox{14cm}{
\hspace*{5cm}\hspace*{-5cm}Студент:\hfill\hbox to\maxl{Попов Павел Сергеевич\hfill}\\
\hspace*{5cm}\hspace*{-5cm}Преподаватель:\hfill\hbox to\maxl{Курц Валентина Валерьевна}\\
\\
\hspace*{5cm}\hspace*{-5cm}Группа:\hfill\hbox to\maxl{5030102/00003}\\}

\vspace{\fill}
\begin{center}
Санкт-Петербург \\2021
\end{center}
\end{titlepage}

\section{Формулировка задачи и её формализация}
\textbf{Задача:}
Найти решение $X$ системы линейных алгебраических уравнений $AX = b$.\\
Решение тестовой СЛАУ с 10 неизвестными найдём с помощью "Метода простых итераций для СЛАУ".\\
Провести исследование №8 - исследовать зависимость нормы ошибки от параметра уменьшения определителя.\\

\section{Алгоритм метода и условия применимости}

\subsection{Алгоритм:}
Пусть имеется СЛАУ:
\begin{center}
\begin{equation*}
 \begin{cases}
   a_{11}x_1 +a_{12}x_2 + \cdots + a_{1n}x_n = b_{1,n+1} 
   \\
   a_{21}x_1 +a_{22}x_2 + \cdots + a_{2n}x_n = b_{2,n+1}
   \\
   \cdots \cdots \cdots \cdots \cdots \cdots \cdots \cdots \cdots \cdots \cdots \cdot \cdot
   \\
    a_{n1}x_1 +a_{n2}x_2 + \cdots + a_{nn}x_n = b_{n,n+1}
   
 \end{cases}
\end{equation*}
\end{center}
Приведём СЛАУ к виду, удобному для МПИ.\\ В матричном виде она имеет вид: $X = CX + \beta$, причем $C = E-\alpha A$, $\beta = \alpha b$, $\alpha = \frac{1}{||A||}$. \\
Будем искать последующее приближение $X^{k+1} = (E-\alpha A) X^{k} + \alpha b$ при помощи предыдущего.\\
\begin{center}
$X=$
$\begin{pmatrix}
x1& \\
x2& \\
\vdots\\
xn&  \\
\end{pmatrix}$ - столбец переменных.
\end{center}

\subsection{Условия применимости:}
Для того, чтобы МПИ было возможно реализовать, необходимо, чтобы $\det(A) \ne 0$.\\
Также необходимо, чтобы матрица была положительно определенной и имела диагональное преобладание.\\
Условие для используемого коэффициента $\alpha$: $\alpha < \frac{2}{||A||}$. \\
Для того, чтобы МПИ сходился при любом начальном векторе $X_{0}$ достаточно, чтобы, бесконечная норма матрицы была меньше единицы: $||C||< 1$. Тогда существует единственное решение $AX=b \leftrightarrow X = CX + \beta $ (*), существует итерационная последовательность (*), сходящаяся к нему. \\
Справедлива оценка (критерий остановки итерационного процесса): \\
\begin{center}
    $||x^{k+1}-x^{k}||<\frac{1-||C||}{||C||}*\epsilon$\\
\end{center}

\section{Предварительный анализ задачи}
Требование: матрица коэффициентов СЛАУ не является вырожденной, т.е. $\det(A) \neq 0$, также является положительно определенной.\\
Это следует из условий построения матрицы (abs(A) = $Q \cdot D \cdot Q'$).\\
$Q$ - ортогональная, а значит невырожденная матрица.\\
$D$ - диагональная, с ненулевыми элементами на диагонали - тоже невырожденная. \\
\\Значит, их произведение - невырожденная матрица $A$.\\
Требование: $||C||<1$. Следует из создания матрицы A с диагональным преобладанием так, что $|c_{ii}| > |a_{1i+1}|+|a_{2i+3}|+|a_{3i+4}| + \cdots + |a_{ni+k}| $. \\

\section{Проверка условий применимости метода}
Условия выполняются автоматически при выбранном способе генерации тестируемых матриц А.\\
Норма матрицы $||C|| < 1$ при взятом $\alpha = \frac{1}{||A||}$.
\section{Тестовый пример с расчетами}
Решим СЛАУ Методом простых итераций.\\

$A = \begin{pmatrix}
3& -1& 1& $\vrule$ &3\\
2& 4& -1& $\vrule$ &5\\
1& 1& -3& $\vrule$ &-1\\
\end{pmatrix};$ 
$X^* = \begin{pmatrix}
 1\\
 1\\
 1 \end{pmatrix}$;\\
Приведем матрицу и правый столбец к виду, удобному для итераций, возьмем $ \alpha = 1$ (Частный случай,  ит.м. Якоби):\\

$\begin{pmatrix}
0& \frac{1}{3}& \frac{-1}{3}& $\vrule$ &1\\
\frac{-1}{2}& 0& \frac{1}{4}& $\vrule$ &\frac{5}{4}\\
\frac{1}{3}& \frac{1}{3}& 0& $\vrule$ &\frac{1}{3}\\
\end{pmatrix};$ $||C||_{\infty} = \frac{3}{4}$;\\
За начальное приближение возьмём столбец свободных коэффициентов и проведем итерации до точности $\epsilon = 0.3$.\\
\begin{tabular}{|p{2.5cm}|p{2cm}|p{2cm}|p{2cm}|p{2cm}|p{2cm}|}
\hline
   № итерации & 0 & 1 & 2 & 3 & 4 \\ \hline
   $x^{k}$ & $\begin{pmatrix} 1\\ 1.25\\ 0.33 \end{pmatrix}$ & $\begin{pmatrix} 1.31\\ 0.83\\ 1.08 \end{pmatrix}$ & $\begin{pmatrix} 0.92\\ 0.86\\ 1.03 \end{pmatrix}$ & $\begin{pmatrix} 0.94\\ 1.05\\ 0.93 \end{pmatrix}$ & $\begin{pmatrix} 1.04\\ 1.01\\ 0.99 \end{pmatrix}$\\ \hline
\end{tabular}


Заметим, что погрешность решения равна: $||x^{(4)}-x^{*}||_{\infty} = \begin{pmatrix} 0.04\\ 0.01\\ 0.01 \end{pmatrix} = \epsilon = 0.04$;\\
 \ Причем по апостериорной оценке: $3 \times ||x^{(4)}-x^{3}||_{\infty} = 0.3$;\\
Из этого напрямую можно сделать вывод о том, что количество итераций при помощи апостериорной оценки будет больше необходимого (лишние итерации).\\

\section{Перечень контрольных тестов}
В качестве проверки результатов исследования построим две зависимости:
\begin{enumerate}
    \item График зависимости относительной погрешности $\frac{|| x - x^{*} ||}{|| x^{*} ||}$ вычислений от изменения определителя тестируемой матрицы. Определитель тестовой матрицы $A$ будем уменьшать с каждым новым тестом, деля матрицу $A$ на $det\_para = 1.51$ и уменьшая диагональный элемент $A[i][i]$ на выбранное значение $\delta = 0.31$. Количество делений и вычитаний будет равно размерности матрицы. На графике: $x^{*}$ - точное решение, сгенерированное в MATLAB, а $x$ - решение, полученное реализованным методом на Си.\\
    \textbf{Замечание:}\\
    Важно отметить, что при таком подходе уменьшения определителя сохраняется диагональное преобладание благодаря изначально сгенерированной диагонали, проверке условия ДП и делению на $det\_para$. Таким образом элементы, стоящие не на главной диагонали, успевают уменьшиться на несколько порядков быстрее, чем диагональ.
    \item График зависимости количества итераций, необходимых для достижения желаемой точности, от различной точности $\epsilon$.
    \item График зависимости скорости работы программы от размерности тестовых матриц. Измеряется при помощи подключения библиотеки <windows.h>.
\end{enumerate}
\section{Модульная структура программы}
\begin{itemize}
\item Константы, определенная через \#define, нужная для введения логики и замеров времени.\\
\#define  NUM\_DIMENSION 2000\\
\#define NUM\_OF\_IMPORTED\_MATRICES 10\\
\#define TRUE 1\\
\#define FALSE 0 \\

\item Функция double* VectorInit(int dimension);\\
Создает(инициализирует) нуль-вектор.\\
Принимает на вход размерность, возвращает указатель на массив double*.\\
\item Функция void VectorDelete(double* vector);\\
Освобождает память, ранее занятую под вектор.\\
Принимает на вход указатель на вектор, ничего не возвращает.\\
\item  Функция void PrintVectorScreen(double* vector, int dimension);\\
Печатает вектор на экран. Отладочная функция.\\
Принимает на вход указатель на вектор и его размерность. Ничего не возвращает.\\
\item  Функция void PrintMatrixScreen(double** vector, int dimension);\\
Печатает матрицу на экран. Отладочная функция.\\
Принимает на вход указатель на матрицу и его размерность. Ничего не возвращает.\\
\item Функция double** ParseMatrix(FILE* f, double** matrix, int dimension);\\
Считывает матрицу из файла.\\
Принимает на вход поток файла, указатель на матрицу, возвращает указатель на матрицу double**.\\
\item Функция double** ParseVector(FILE* g, double* vector, int dimension);\\
Считывает вектор из файла.\\
Принимает на вход поток файла, указатель на вектор, возвращает указатель на вектор double*.\\
\item  Функция void PrintVector(FILE* g, double* vector, int dimension);\\
Печатает вектор в файл.\\
Принимает на вход поток файла, указатель на вектор и его размерность. Ничего не возвращает.\\
\item Функция double** MergeMatrix(double** A, double* B, int dimension);\\
Обеспечивает слияние матрицы $A$ и вектор-столбца $B$.\\
Принимает на вход матрицу $A$ и вектор-столбец $B$,  возвращает расширенную матрицу СЛАУ.\\
\item Функция double Norm(double** C, int dimension);
Находит норму матрицы.\\ 
Принимает на вход матрицу $C$.
\item Функция int ConditionStop(double* cur, double* prev, int dimension, double eps, double Cnorm);\\
Реализует условие остановки итерационного процесса. Принимает на вход массивы текущего и предыдущего приближений, их размерность, желаемую точность и норму матрицы $C$. Возвращает идентификатор TRUE или FALSE.
\item Функция double* MPI(double** A, double* B, int dimension, double eps, double alpha, double Cnorm, double** C, int* iter);\\
Реализует непосредственно метод простых итераций.\\
Принимает на вход матрицу $A$, вектор-столбец $B$, размерность решения $X$, желаемую точность $eps$, параметр $\alpha$, норму матрицы $C$, и адрес переменной, в которую записывается количество итераций $iter$. Возвращает полученное методом решение.
\end{itemize}











\section{Численный анализ решения задачи}
\subsection{Зависимость относительной погрешности от количества уменьшений определителя матрицы $A$ на $num\_para$}
\begin{figure}[h!]
\center
\includegraphics[width=1\textwidth]{num_of_reds.png}
\caption{Зависимость погрешности от количества уменьшений определителя}
\label{error_cond}
\end{figure}
\newpage
Из графика ясно видно, что количестве уменьшений определителя $ num\_para \in [1,10]$ ошибка близка к постоянному значению $6 * 10e^{-15}$.\\
Конкретной зависимости не прослеживается, что вполне ожидаемо, т.к. особых требований к определителю, кроме логичного неравенства нулю, нет.\\
Контрольное значение определителя при $num\_para = 10 $ равно $\delta e^{-11}$.
\subsection{Зависимость количества итераций от $\epsilon$}
\begin{figure}[h!]
\center
\includegraphics[width=1\textwidth]{iterations.png}
\caption{Зависимость количества итераций от требуемого $\epsilon$}
\label{error_cond}
\end{figure}
Из графика видно, что чем больше требуемая точность - тем больше итераций нужно. Соответствует ожиданиям.\\
\newpage
\subsection{Зависимость времени от размерности для метода вращений}
\begin{figure}[h!]
\includegraphics[width=1\textwidth]{time_rotations.png}
\caption{Зависимость времени от размерности для метода вращений}
\label{error_errorData}
\end{figure}
График показывает, что время работы на матрицах размера 100x100 и более исчисляется в секундах.\\
\newpage
\subsection{Зависимость времени работы от размерности матрицы для МПИ}
\begin{figure}[h!]
\includegraphics[width=1\textwidth]{time_MPI.png}
\caption{Зависимость времени от размерности для метода простых итераций}
\label{error_errorData}
\end{figure}
Из графика видно, что время работы даже на больших матрицах исчисляется в мс. График аппроксимирован к $O(x^3)$.
\newpage
\subsection{Сравнение времени работы двух методов на одних осях}
\begin{figure}[h!]
\includegraphics[width=1\textwidth]{comparison.png}
\caption{Зависимости времени двух методов}
\label{error_errorData}
\end{figure}
Наглядное сравнение графиков.
\pagebreak
\newpage
\section{Краткие выводы}
В данной работе я проанализировал решение СЛАУ при помощи "Метода простых итераций".\\ 
С уменьшением требуемой точности количество итераций возрастает.\\
Ручными вычислениями подтверждено, что засчёт апостериорной оценки могут появиться лишние итерации.\\
Исследованием подтверждено, что с уменьшением определителя до значения $\delta e^{-11}$ посредством уменьшения диагонального элемента $A[i,i]$ $num\_para \in [1,10]$, ошибка близка к постоянному значению, что вполне ожидаемо. Желаемая точность достигается.\\ 
Также исследованием подтверждено, что итерационный метод в разы быстрее прямого метода вращений из Лабораторной работы №2.\\
Итерационный метод даёт быстрое, точное, но приближённое решение, в то время как прямой метод вращений даёт точное решение, но работает гораздо дольше (в $10^{3}$ раз).\\


\begin{equation}
   \begin{cases}
   (\frac{1}{4}-j\frac{1}{4})\dot{U}_{10}- (\frac{1}{4}-j\frac{1}{4})\dot{U}_{20} =j\\
   -(\frac{1}{4}-j\frac{1}{4})\dot{U}_{10}+(\frac{1}{4}+j\frac{3}{4})\dot{U}_{20} = 2-j2\\
   \end{cases}
    
\end{equation}


\end{document}