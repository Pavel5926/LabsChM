\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage[pdftex]{graphicx}
\usepackage{amsmath}
\usepackage{geometry} % Меняем поля страницы
\geometry{left=1.5cm}% левое поле
\geometry{right=2cm}% правое поле
\geometry{top=1cm}% верхнее поле
\geometry{bottom=2cm}% нижнее поле
\graphicspath{{.}}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}

\begin{document}

\begin{titlepage}
\Large

\begin{center}
Санкт-Петербургский \\ Политехнический университет Петра Великого

\vspace{10em}

Отчет по лабораторной работе №4\\
\\

\vspace{2em}

\textbf{Решение алгебраической проблемы собственных значений итерационными
методами}
\end{center}

\vspace{6em}

\newbox{\lbox}
\savebox{\lbox}{\hbox{Корнелюк Алексей Викторович}}
\newlength{\maxl}
\setlength{\maxl}{\wd\lbox}
\hfill\parbox{14cm}{
\hspace*{5cm}\hspace*{-5cm}Студент:\hfill\hbox to\maxl{Попов Павел Сергеевич\hfill}\\
\hspace*{5cm}\hspace*{-5cm}Преподаватель:\hfill\hbox to\maxl{Курц Валентина Валерьевна}\\
\\
\hspace*{5cm}\hspace*{-5cm}Группа:\hfill\hbox to\maxl{5030102/00003}\\}

\vspace{\fill}
\begin{center}
Санкт-Петербург \\2022
\end{center}
\end{titlepage}
\section{Формулировка задачи и её формализация}
\textbf{Задача:}
Дана матрица А размера $n\times n$. Решить частичную АПСЗ при помощи степенного метода с нормировкой (PM - алгоритм), вычислив первое и второе максимальные по модулю сообственные числа и собственные векторы (СЧ) и (СВ). \\
Провести необходимые исслдования: исследовать зависимость числа итераций от $\epsilon$ при фиксированном числе отделимости; исследовать зависимость числа итераций от числа отделимости при фиксированной точности $\epsilon.$
\section{Алгоритм метода и условия применимости}
\subsection{Алгоритмы метода:}
Пусть имеется Матрица $A$ такая, что $\displaystyle A = A^T \rightarrow (w^{i},w^{j}) = \delta_{ij}$ - собственные векторы $A$.Пусть СЧ упорядочены: $|\lambda_1| >|\lambda_2| > ... > |\lambda_n|$.\\
\textbf{PM - алгоритм для первого СЧ и СВ:}\\
Шаг 1: Ввести $n\times n$ матрицу $A$, задать n-мерный вектор $y^{(0)}$, вычислить $\displaystyle||y^{(0)}||$ и вектор $\displaystyle x^{(0)} = \frac{y^{(0)}}{||y^{(0)}||}$.\\
Шаг 2: Вычислить вектор $\displaystyle y^{(k)} = Ax^{(k-1)}$.\\
Шаг 3: Вычислить $||y^{(k)}||$ и $\displaystyle x^{(k)} = \frac{y^{(k)}}{||y^{(k)}||}$.\\
Шаг 4: Вычислить отношения $\displaystyle \lambda_i = \frac{y^{(k)}_i}{x^{(k-1)}_i}$ при $i \in (1,2,... n)$. 
Заметим, что $x^{(k)}$ - $k$-ое приближение СВ матрицы $A$.\\
Шаг 5: Подвергнем  $x^{(k)}$ тесту на сходимость по апостериорной оценке: $\displaystyle \frac{||Ax_1^{(k)}-\lambda_1^{(k)}x_1^{(k)}||}{||x_1^{(k)}||}< \epsilon$.\\
В случае остановки итерационного процесса при выполнении заданного условия, получим: $\lambda_1^{(k)}$ - $k$-ое приближение первого СЧ матрицы $A$, $x^{(k)}$ - $k$-ое приближение первого СВ матрицы $A$.
\textbf{Алгоритм нахождениния второго СЧ и СВ:}\\ 
Пусть имеется та же матрицы $A$ с тем же условием, и уже известнs $\lambda_1$ и $w^{(1)}$. Тогда:\\
Возьмем произвольный вектор $x^{(0)}\in R^n$ и разложим его по ОНБ из собственных векторов:  $\displaystyle x^{(0)}= \sum\limits_{j=1}^n \alpha_j w^{(j)}$;\\
Вычислим $y^{(0)} = x^{(0)} - \gamma w^{(1)}$, причём выбрав $\gamma$ так, что $(y^{(0)},w^{(1)}) = 0 \rightarrow\gamma =\alpha_1$;\\
Вычислим $y^{(0)} =\sum\limits_{j=2}^n \alpha_j w^{(j)}$;
Пусть СЧ упорядочены: $|\lambda_2| >|\lambda_3| > ... > |\lambda_n|$.\\
Тогда применим степенной метод:\\ $\displaystyle y^{(k)} = A^k y^{(0)} = \alpha_2\lambda_2w^{(2)}(1+ O(|\frac{\lambda_2}{\lambda_1}|))$. Заметим, что $|\frac{\lambda_2}{\lambda_1}|$ - число отделимости. Оно характеризует скорость сходимости метода.\\
Будем проводить ортогонализацию на каждом шаге, поэтому итерационную последовательность строим по формулам:\\
$\displaystyle x^{(k)} = A y^{(k-1)}$;\\
$\displaystyley^{(k)} = x^{(k)} - \gamma w^{(j)}$.\\
$\lambda_2^{(k)}$ - $k$-ое приближение второго СЧ матрицы $A$, $\displaystyle x^{(k)}$ - $k$-ое приближение второго СВ.\\
Критерий остановки СЧ и СВ - апостериорная оценка: $\displaystyle \frac{||Ax_2^{(k)}-\lambda_2^{(k)}x_2^{(k)}||}{||x_2^{(k)}||}< \epsilon$.
\subsection{Условия применимости:}
Для поиска первого СЧ и СВ достаточно, чтобы матрица $A$ была матрицей простой структуры.\\
Для поиска второго СЧ и СВ нужно условие $\displaystyle A = A^T \rightarrow (w^{i},w^{j}) = \delta_{ij}$.
\section{Предварительный анализ задачи}
Заметим, что для поиска первого СЧ и СВ достаточно, чтобы матрица $A$ была матрицей простой структуры. Следовательно с помощью преобразований её можно привести к ортогональному виду: $G^{-1}AG = diag\lambda_i$.\\ Однако для поиска второго СЧ и СВ нужно условие $\displaystyle A = A^T \rightarrow (w^{i},w^{j}) = \delta_{ij}$.\\
Сгенерируем тестовые матрицы в соответствии с этим условием: $[Q,R] = rand(dimension)$, $A = Q^{-1}DQ$.\\
Получена матрица $А$ простой структуры, симметричная относительно главной диагонали.\\
\section{Проверка условий применимости метода}
При выбранном способе генерации тестируемых матриц $A$ условия выполняются автоматически.
\section{Тестовый пример с расчётами}
Возьмем симметрическую матрицу прострой структуры размера $3\times3$;\\
$A = \begin{pmatrix}
5.61& -0.02& -1.28 \\
-0.02& 4.43& 4.19\\
-1.28& 4.19& 6.45\\
\end{pmatrix};$ Известно, что: $\lambda_1^* = 10$, $\lambda_2^* = 5.5$.\\
Занесём промежуточные данные по поиску первого СЧ в таблицу с точностью до $\epsilon = 0.1$. Здесь$\displaystyle AO_1 =  \frac{||Ax_1^{(k)}-\lambda_1^{(k)}x_1^{(k)}||}{||x_1^{(k)}||} $.\\
\begin{tabular}{|p{2cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|}
\hline
   № итерации & 1 & 2 & 3 & 4 & 5 & 6 & 7\\ \hline
   $x_1^{k}$ &$\begin{pmatrix} 0.45\\ 0.91\\ 1.00 \end{pmatrix}$ &$\begin{pmatrix} 0.13\\ 0.84\\ 1.00 \end{pmatrix}$  &$\begin{pmatrix} -0.05\\ 0.80\\ 1.00 \end{pmatrix}$  &$\begin{pmatrix} -0.16\\ 0.78\\ 1.00 \end{pmatrix}$ &$\begin{pmatrix} -0.22\\ 0.77\\ 1.00 \end{pmatrix}$ &$\begin{pmatrix} -0.25\\ 0.76\\ 1.00 \end{pmatrix}$  & $\begin{pmatrix} -0.27\\ 0.75\\ 1.00 \end{pmatrix}$ \\ \hline
   $\lambda_1$ & 4.29 &2.75 &-4.41 &27.9 &13.5 &11.4 &10.074 \\\hline
   $AO_1$ & 4.851 &4.893 &14.277 &18.011 &3.557 &1.447&0.087 \\ \hline
\end{tabular}\\Получено приближение для первого СЧ и СВ.
\newpage
Для нахождения второго СЧ требуется знание $\lambda_1$ и $w_1$. Возьмем достаточно точное $\lambda_1 = 10.000000001$, $w_1 = (-0.28175,0.74376, 1)$ и на основе него найдём $\lambda_2$ c точностью до $\epsilon = 1e-6$.\\
\begin{tabular}{|p{2cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{2cm}|p{2.cm}|p{2cm}|p{2cm}|}
\hline
   № итерации & 1 & 2 & 3 & 4 & 5 & 6 & 7\\ \hline
   $x_2^{k}$ &$\begin{pmatrix} 1\\ 0.91\\ 1.00 \end{pmatrix}$ &$\begin{pmatrix} 1\\ 0.2836\\ 0.0829 \end{pmatrix}$  &$\begin{pmatrix} 1\\ 0.2870\\ 0.0829 \end{pmatrix}$  &$\begin{pmatrix} 1\\ 0.2876\\ 0.08005\end{pmatrix}$ &$\begin{pmatrix} 1\\ 0.28779\\ 0.080035 \end{pmatrix}$ &$\begin{pmatrix} 1\\ 0.28779\\ 0.080034 \end{pmatrix}$  & $\begin{pmatrix} 1\\ 0.28779\\ 0.080032 \end{pmatrix}$ \\ \hline
   $\lambda_1$ & 11.336 &5.496 &5.499 &5.4998 &5.499978 &5.499996 & 5.499999\\\hline
   $AO_1$ & 5.836 &0.0051 &0.0009 &0.00017 &0.00003 &0.0000056&0.0000010 \\ \hline
\end{tabular}
\section{Перечень контрольных тестов}
Выполним исследования:
\begin{itemize}
    \item Исследование количества итераций от числа отделимости при фиксированном $\epsilon = 1e-15$. $sep\_val_i \in [1.05, 1.95],  i = 1,2,..., 10$.
    \item Исследование количества итераций от точности вычислений $\epsilon \in[10^{-15}, 10^{-5}]$ при фиксированном $sep\_val = 1.15$.
    \item Проверка на достижение желаемой точности при фиксированном $sep\_val = 1.15$.
\end{itemize}
\section{Модульная структура программы}
\begin{itemize}
\item Константы, определенная через \#define, нужная для введения логики и остановки бесконечного цикла (в исключительных случаях).\\

\#define NUMBER\_OF\_TESTS 10\\
\#define TRUE 1\\
\#define FALSE 0 \\
\#define MAX\_STEPS 7000
\item Функция double* VectorInit(int dimension);\\
Создает(инициализирует) нуль-вектор.\\
Принимает на вход размерность, возвращает указатель на массив double*.\\
\item Функция void VectorDelete(double* vector);\\
Освобождает память, ранее занятую под вектор.\\
Принимает на вход указатель на вектор, ничего не возвращает.\\
\item  Функция void PrintVectorScreen(double* vector, int dimension);\\
Печатает вектор на экран. Отладочная функция.\\
Принимает на вход указатель на вектор и его размерность. Ничего не возвращает.\\
\item  Функция void PrintMatrixScreen(double** vector, int dimension);\\
Печатает матрицу на экран. Отладочная функция.\\
Принимает на вход указатель на матрицу и его размерность. Ничего не возвращает.\\
\item Функция double** ParseMatrix(FILE* f, double** matrix, int dimension);\\
Считывает матрицу из файла.\\
Принимает на вход поток файла, указатель на матрицу, возвращает указатель на матрицу double**.\\
\item Функция double** ParseVector(FILE* g, double* vector, int dimension);\\
Считывает вектор из файла.\\
Принимает на вход поток файла, указатель на вектор, возвращает указатель на вектор double*.\\
\item  Функция void PrintVector(FILE* g, double* vector, int dimension);\\
Печатает вектор в файл.\\
Принимает на вход поток файла, указатель на вектор и его размерность. Ничего не возвращает.
\item Функция double** MergeMatrix(double** A, double* B, int dimension);\\
Обеспечивает слияние матрицы $A$ и вектор-столбца $B$.\\
Принимает на вход матрицу $A$ и вектор-столбец $B$,  возвращает расширенную матрицу СЛАУ.\\
\item Функция double NormVec(double* B, int dimension);\\
Возвращает Евклидову норму вектора.\\ 
\item Функция double NormVecInf(double* B, int dimension);\\
Возвращает бесконечную норму вектора.\\ 
Принимает на вход матрицу $C$.

\item ФУнкция void MMBV(double** A, double* B, double* result, int dimension);\\
Умножает матрицу А на вектор B и кладёт результат в result.\\
Ничего не возвращает.
\item void DV(double* A, double* B, double* result, int dimension);\\
Реализует разность векторов A и B, кладёт результат в result.\\
Ничего не возвращает.
\item void MVBN(double* B, double* result, double num, int dimension);
Реализует умножение вектора B  на число num, результат кладёт в result.\\
Ничего не возвращает.
\item void DVBN(double* B, double* result, double num, double dimension);\\
Делит вектор Bна число num, результат кладёт в result.
\item int Shift(double* prev, double* Xcur, int dimension)
Копирует данные по адресу Xcur в адрес prev.\\
Возвращает TRUE или FALSE.
\item double* PMM1(double** A, int dimension, double* eigenvalues, int* iter, double eps);\\
Выполняет поиск первого СЧ и СВ степенным методом. Возвращает первый собственный вектор, нормированный по бесконечной норме. Собственные числа кладёт в массив eigenvalues.
\item double* PMM2(double** A, int dimension, double* eigenvalues, int* iter, double eps);\\
Выполняет поиск второго СЧ и СВ степенным методом. Возвращает второй собственный вектор, нормированный по бесконечной норме. Собственные числа кладёт в массив eigenvalues.

\item Функция int ConditionStop((double** A, double* Xcur, double* eigenvalues, int dimension, int eignum, double eps));\\
Реализует условие остановки итерационного процесса. Принимает на вход матрицу, текущее приближение, массив собственных чисел, размерность, номер СЧ и точность.\\ Возвращает идентификатор TRUE или FALSE.

\end{itemize}



\section{Численный анализ решения задачи}
\subsection{Зависимость количества итераций от $sep\_val \in [1.05,1.95]$. }
\begin{figure}[h!]
\center
\includegraphics[width=0.7\textwidth]{it_sepval.png}
\caption{Зависимость количества итераций от числа отделимости $sep\_val$}
\end{figure}
Из графика видно, что чем хуже отделимость (близость к 1), тем больше итераций требует метод.
\subsection{Зависимость количества итераций от $\epsilon \in [10^{-15},10^{-5}]$.}
\begin{figure}[h!]
\center
\includegraphics[width=0.7\textwidth]{it_eps.png}
\caption{Зависимость количества итераций от требуемого $\epsilon$}
\end{figure}
Из графика видно, что чем больше желаемая точность - тем больше итераций требуется. 
\newpage
\subsection{Достигается ли точность? Абсолютная погрешность меньше эпсилон. $sep\_val = 1.15$.}
\begin{figure}[h!]
\center
\includegraphics[width=0.7\textwidth]{accurate.png}
\caption{График полученной абсолютной погрешности.}
\end{figure}
Из графика видно, что эпсилон, полученный в процессе решения, не превышает допустимого, а значит, что метод выполнен достаточно точно.
\section{Краткие выводы}
В лабораторной работе был выполнен поиск первого и второго максимального по модулю $\lambda_1$ и $\lambda_2$ и соответствующих им СВ. \\
Проанализированы зависимости:\\
1) Количества итераций от числа отделимости. Результат исследования ожидаем : степенной метод хуже сходится при отделимости, близкой к единице.\\
2) Количества итераций от требуемой точности. Результат также без отклонений : чем лучше требуемая точность, тем больше итераций требуется.\\
3) График абсолютной погрешности от желаемого эпсилон. Результатом графака ожидалось расположение тестовых кривых ниже $ y = x = \epsilon$, результат получен, точность соблюдается.

\end{document}